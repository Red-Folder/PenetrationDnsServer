using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using DNS.Protocol;
using DNS.Protocol.ResourceRecords;
using DNS.Client;
using DNS.Client.RequestResolver;
using DNS.Server;
using System.Diagnostics;

namespace DnsServer
{
    class PenTestingDnsServer
    {
        private const int DEFAULT_PORT = 53;
        private const int UDP_TIMEOUT = 2000;
        private const int UDP_LIMIT = 512;

        private UdpClient udp;
        //private EventEmitter emitter;
        //private DnsClient client;
        private IPEndPoint local;

        public PenTestingDnsServer(/*IPEndPoint endServer*/)
        {
            //this.emitter = new EventEmitter();
            //this.client = new DnsClient(endServer, new UdpRequestResolver());
            //this.masterFile = new MasterFile();
        }

        //public PenTestingDnsServer(IPAddress endServer, int port = DEFAULT_PORT) : this(new IPEndPoint(endServer, port)) { }
        //public PenTestingDnsServer(string endServerIp, int port = DEFAULT_PORT) : this(IPAddress.Parse(endServerIp), port) { }

        public void Listen(int port = DEFAULT_PORT)
        {
            udp = new UdpClient(port);

            local = new IPEndPoint(IPAddress.Any, port);

            //emitter.Run();
            udp.Client.SendTimeout = UDP_TIMEOUT;

            Trace.TraceInformation("Start run");

            StartListen();
        }

        private void StartListen()
        {
            try
            {
                //Trace.TraceInformation("To check for UDP on {0}", local.ToString());
                udp.BeginReceive(new AsyncCallback(HandleReceive), null);
            }
            catch (SocketException ex)
            {
                Trace.TraceError("Error occurred: {0}", ex);
            }
        }

        private void HandleReceive(IAsyncResult asyncResult)
        {
            byte[] clientMessage = null;
            clientMessage = udp.EndReceive(asyncResult, ref local);
            StartListen();

            var request = Request.FromArray(clientMessage);

            var response = Response.FromRequest(request);

            var domain = new Domain(request.Questions[0].Name.ToString().Replace(".Home", ""));
            var ipAddress = IPAddress.Parse("127.0.0.1");
            var ttl = new TimeSpan(0);
            response.AnswerRecords.Add(new IPAddressResourceRecord(domain, ipAddress, ttl));

            udp.Send(response.ToArray(), response.Size, local);
        }

        public void Close()
        {
            if (udp != null)
            {
                //run = false;

                //emitter.Stop();
                udp.Close();
            }
        }

        //public MasterFile MasterFile
        //{
        //    get { return masterFile; }
        //}

        //protected virtual void OnRequested(IRequest request)
        //{
        //    RequestedEventHandler handlers = Requested;
        //    if (handlers != null) handlers(request);
        //}

        //protected virtual void OnResponded(IRequest request, IResponse response)
        //{
        //    RespondedEventHandler handlers = Responded;
        //    if (handlers != null) handlers(request, response);
        //}

        //protected virtual IResponse ResolveLocal(Request request)
        //{
        //    Response response = Response.FromRequest(request);

        //    foreach (Question question in request.Questions)
        //    {
        //        IList<IResourceRecord> answers = masterFile.Get(question);

        //        if (answers.Count > 0)
        //        {
        //            Merge(response.AnswerRecords, answers);
        //        }
        //        else
        //        {
        //            return ResolveRemote(request);
        //        }
        //    }

        //    return response;
        //}

        //protected virtual IResponse ResolveRemote(Request request)
        //{
        //    ClientRequest remoteRequest = client.Create(request);
        //    return remoteRequest.Resolve();
        //}

        //private static void Merge<T>(IList<T> l1, IList<T> l2)
        //{
        //    foreach (T obj in l2)
        //    {
        //        l1.Add(obj);
        //    }
        //}
    }

    internal class EventEmitter
    {
        public delegate void Emit();

        private CancellationTokenSource tokenSource;
        private BlockingCollection<Emit> queue;

        public void Schedule(Emit emit)
        {
            if (queue != null)
            {
                queue.Add(emit);
            }
        }

        public void Run()
        {
            tokenSource = new CancellationTokenSource();
            queue = new BlockingCollection<Emit>();

            (new Thread(() => {
                try
                {
                    while (true)
                    {
                        Emit emit = queue.Take(tokenSource.Token);
                        emit();
                    }
                }
                catch (OperationCanceledException) { }
            })).Start();
        }

        public void Stop()
        {
            if (tokenSource != null)
            {
                tokenSource.Cancel();
            }
        }
    }
}

